/**
 * Parses a task text into a XML document.
 * The task text is an empty drag and drop task generated by Inspera in QTI 2.1.
 * Each task created becomes its own xml document.
 * @return {XMLDocument object}	A empty drag and drop xml document
 */
function read_xml() {
	let text = '<?xml version="1.0" encoding="UTF-8"?><assessmentItem xmlns="http://www.imsglobal.org/xsd/imsqti_v2p1" xsi:schemaLocation="http://www.imsglobal.org/xsd/imsqti_v2p1  http://www.imsglobal.org/xsd/qti/qtiv2p1/imsqti_v2p1.xsd" identifier="28416605" title="Ny oppgave" adaptive="false" timeDependent="false" xmlns:java="http://xml.apache.org/xalan/java" xmlns:imsmd="http://www.imsglobal.org/xsd/imsmd_v1p2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"><responseDeclaration identifier="RESPONSE" cardinality="multiple" baseType="directedPair"><correctResponse></correctResponse><mapping defaultValue="0"></mapping></responseDeclaration><outcomeDeclaration identifier="SCORE" cardinality="single" baseType="float"><defaultValue><value>0</value></defaultValue></outcomeDeclaration><outcomeDeclaration identifier="FEEDBACK" cardinality="single" baseType="identifier"/><templateDeclaration identifier="SCORE_EACH_CORRECT" cardinality="single" baseType="float"><defaultValue><value>1</value></defaultValue></templateDeclaration><templateDeclaration identifier="SCORE_EACH_WRONG" cardinality="single" baseType="float"><defaultValue><value>0</value></defaultValue></templateDeclaration><templateDeclaration identifier="SCORE_ALL_CORRECT" cardinality="single" baseType="float"><defaultValue><value/></defaultValue></templateDeclaration><templateDeclaration identifier="SCORE_MINIMUM" cardinality="single" baseType="float"><defaultValue><value/></defaultValue></templateDeclaration><templateDeclaration identifier="SCORE_UNANSWERED" cardinality="single" baseType="float"><defaultValue><value>0</value></defaultValue></templateDeclaration><itemBody inspera:defaultLanguage="no_no" inspera:supportedLanguages="no_no" xmlns:inspera="http://www.inspera.no/qti"><div class="question-main-illustration"></div><p style="">Fullfør denne dra og slipp oppgaven!</p><graphicGapMatchInteraction class="markHotspots " responseIdentifier="RESPONSE" inspera:canvasHeight="400" inspera:mode="IA"><prompt>Velg ett alternativ</prompt></graphicGapMatchInteraction><p style=""> </p></itemBody><responseProcessing><responseCondition><responseIf><and><isNull><variable identifier="RESPONSE"/></isNull></and><setOutcomeValue identifier="SCORE"><variable identifier="SCORE_UNANSWERED"/></setOutcomeValue></responseIf><responseElse><setOutcomeValue identifier="SCORE"><sum><variable identifier="SCORE"/><mapResponse identifier="RESPONSE"/></sum></setOutcomeValue></responseElse></responseCondition><responseCondition><responseIf><and><isNull><variable identifier="RESPONSE"/></isNull></and><setOutcomeValue identifier="FEEDBACK"><baseValue baseType="identifier">feedback_unanswered</baseValue></setOutcomeValue></responseIf><responseElseIf><and></and><setOutcomeValue identifier="FEEDBACK"><baseValue baseType="identifier">feedback_correct</baseValue></setOutcomeValue></responseElseIf><responseElseIf><or></or><setOutcomeValue identifier="FEEDBACK"><baseValue baseType="identifier">feedback_partially_correct</baseValue></setOutcomeValue></responseElseIf><responseElse><setOutcomeValue identifier="FEEDBACK"><baseValue baseType="identifier">feedback_wrong</baseValue></setOutcomeValue></responseElse></responseCondition><responseCondition inspera:type="max_score_upper_bound" xmlns:inspera="http://www.inspera.no/qti"><responseIf><and><gte><variable identifier="SCORE"/><baseValue baseType="float">3.0</baseValue></gte></and><setOutcomeValue identifier="SCORE"><baseValue baseType="float">3.0</baseValue></setOutcomeValue></responseIf></responseCondition></responseProcessing><modalFeedback outcomeIdentifier="FEEDBACK" identifier="feedback_unanswered" showHide="show">Ubesvart</modalFeedback><modalFeedback outcomeIdentifier="FEEDBACK" identifier="feedback_wrong" showHide="show">Galt svar</modalFeedback><modalFeedback outcomeIdentifier="FEEDBACK" identifier="feedback_correct" showHide="show">Riktig svar</modalFeedback><modalFeedback outcomeIdentifier="FEEDBACK" identifier="feedback_partially_correct" showHide="show">Delvis riktig svar</modalFeedback></assessmentItem>';
	let parser = new DOMParser();
	let xmlDoc = parser.parseFromString(text, "text/xml");
	return xmlDoc;
}

/**
 * Parses the manifest text into a XML document.
 * The text string is a default manifest created by Inspera in QTI 2.1
 * The manifest contains information regarding what tasks belong to the question-set.
 * Every exported zip file contains one or more tasks and one single manifest file.
 * zipfile [
 * 	task1.xml
 * 	task2.xml
 * 	manifest.xml		
 * ]
 * @return {XMLDocument object}	A default manifest xml document
 */
function read_manifest() {
	let text = '<?xml version="1.0" encoding="UTF-8"?><manifest identifier="MANIFEST" version="1.1" xmlns="http://www.imsglobal.org/xsd/imscp_v1p1" xmlns:java="http://xml.apache.org/xalan/java" xmlns:imsmd="http://www.imsglobal.org/xsd/imsmd_v1p2"><metadata><imsmd:lom><imsmd:lifecycle><imsmd:status><imsmd:source><imsmd:langstring xml:lang="x-none">LOMv1.0</imsmd:langstring></imsmd:source><imsmd:value><imsmd:langstring xml:lang="x-none">Draft</imsmd:langstring></imsmd:value></imsmd:status></imsmd:lifecycle></imsmd:lom></metadata><resources><resource identifier="ID_28416605" type="imsqti_item_xmlv2p1" href="content_question_qti2_graphicgapmatch_28416605.xml"><metadata><imsmd:lom><imsmd:general><imsmd:identifier/><imsmd:title><imsmd:langstring xml:lang="no">Ny oppgave</imsmd:langstring></imsmd:title></imsmd:general></imsmd:lom></metadata><file href="content_question_qti2_graphicgapmatch_28416605.xml"/></resource></resources></manifest>';
	let parser = new DOMParser();
	let xmlDoc = parser.parseFromString(text, "text/xml");
	return xmlDoc;
}

/**
 * Exports the given xml document to an actual file and places the file in the folder to be zipped.
 * All files are placed in a folder called zipThis
 * @param {XMLDocument object} xmlDoc The xml document object to be written to file
 * @param {String} taskIdentifier The unique id given to the xml document
 */
function write_xml(xmlDoc, taskIdentifier) {
	let serializer = new XMLSerializer();
	let xmlString = serializer.serializeToString(xmlDoc);
	let fs = require('fs');

	if (fs.existsSync(__dirname + "/zipThis")) {
		fs.writeFile(__dirname + '/zipThis/content_question_qti2_graphicgapmatch_' + taskIdentifier + '.xml', xmlString, function (err) {
			if (err) {
				return console.log("Creating file in write_xml error: " + err);
			}
		});
	} else {
		alert("ZipThis path NOT found in write_xml. Im looking for: " + __dirname + "/zipThis");
	}
}

/**
 * Exports the given xml manifest document to an actual file and places the file in the folder to be zipped.
 * All files are placed in a folder called zipThis
 * @param {XMLDocument object} xmlDoc The xml manifest document object to be written to file
 */
function write_manifest(xmlDoc) {
	let serializer = new XMLSerializer();
	let xmlString = serializer.serializeToString(xmlDoc);
	let fs = require('fs');
	fs.writeFile(__dirname + '/zipThis/imsmanifest.xml', xmlString, function (err) {
		if (err) {
			return console.log("Writing manifest error: " + err);
		}
	});
}

/**
 * Adds the required data to the manifest xml document
 * @param {XMLDocument object} myManifest The manifest xml document object
 * @param {String or [Strings]} identifiers A single identifier(id) string or an array of identifiers (When multiple tasks are created)
 * @param {String or [Strings]} taskNames A single task name or an array of task names (When multiple tasks are created)
 */
function add_manifest_data(myManifest, identifiers, taskNames) {
	if (Array.isArray(identifiers)) {
		let identifier = identifiers[0];
		let taskName = taskNames[0];
		let fileName = 'content_question_qti2_graphicgapmatch_' + identifier + '.xml';
		let manifestTag = myManifest.getElementsByTagName('manifest')[0];
		let resourcesTag = manifestTag.getElementsByTagName('resources')[0];
		let resourceTag = resourcesTag.getElementsByTagName('resource')[0];

		//Name
		let metadata = resourceTag.getElementsByTagName('metadata')[0];
		let lom = metadata.getElementsByTagName('imsmd:lom')[0];
		let general = lom.getElementsByTagName('imsmd:general')[0];
		let title = general.getElementsByTagName('imsmd:title')[0];
		let langstring = title.getElementsByTagName('imsmd:langstring')[0];
		langstring.firstChild.nodeValue = taskName;

		addAttribute(resourceTag, "identifier", "ID_" + identifier);
		addAttribute(resourceTag, "href", fileName);
		let fileTag = resourceTag.getElementsByTagName('file')[0];
		addAttribute(fileTag, "href", fileName);

		if (identifiers.length > 1) {
			for (let i = 1; i < identifiers.length; i++) {
				let identifier = identifiers[i];
				let taskName = taskNames[1];
				let fileName = 'content_question_qti2_graphicgapmatch_' + identifier + '.xml';
				let cloneResourceTag = resourceTag.cloneNode(true);

				//Name
				let metadata = cloneResourceTag.getElementsByTagName('metadata')[0];
				let lom = metadata.getElementsByTagName('imsmd:lom')[0];
				let general = lom.getElementsByTagName('imsmd:general')[0];
				let title = general.getElementsByTagName('imsmd:title')[0];
				let langstring = title.getElementsByTagName('imsmd:langstring')[0];
				langstring.firstChild.nodeValue = taskName;

				addAttribute(cloneResourceTag, "identifier", "ID_" + identifier);
				addAttribute(cloneResourceTag, "href", fileName);
				let fileTag = cloneResourceTag.getElementsByTagName('file')[0];
				addAttribute(fileTag, "href", fileName);

				resourcesTag.appendChild(cloneResourceTag);

			}
		}
	} else {
		let identifier = identifiers;
		let taskName = taskNames;
		let fileName = 'content_question_qti2_graphicgapmatch_' + identifier + '.xml';
		let manifestTag = myManifest.getElementsByTagName('manifest')[0];
		let resourcesTag = manifestTag.getElementsByTagName('resources')[0];
		let resourceTag = resourcesTag.getElementsByTagName('resource')[0];

		//Name
		let metadata = resourceTag.getElementsByTagName('metadata')[0];
		let lom = metadata.getElementsByTagName('imsmd:lom')[0];
		let general = lom.getElementsByTagName('imsmd:general')[0];
		let title = general.getElementsByTagName('imsmd:title')[0];
		let langstring = title.getElementsByTagName('imsmd:langstring')[0];
		langstring.firstChild.nodeValue = taskName;

		addAttribute(resourceTag, "identifier", "ID_" + identifier);
		addAttribute(resourceTag, "href", fileName);
		let fileTag = resourceTag.getElementsByTagName('file')[0];
		addAttribute(fileTag, "href", fileName);
	}

}

/**
 * Adds the tag lang="languageCode" to all children of the temp node.
 * @param {Node} temp Parent node 
 * @param {String} languageCode Language code (no_no, no_no_ny or en_us)
 */
function addLanguageToAllTags(temp, languageCode) {
	var all = temp.childNodes;//getElementsByTagName("*");
	for (var i = 0, max = all.length; i < max; i++) {
		var tagname = all[i];
		addAttribute(tagname, "lang", languageCode);
		addAttribute(tagname, "style", "display: none;");
	}
}

/**
 * Adds required 'metadata' to the task xml document object. 
 * Adds data such as 
 * 	- Task title
 * 	- Supported languages (no, ny, en)
 * 	- Different titles and prompt texts for each language
 * 	- Canvas height
 * 	- Free placing drag areas if not 2D parsons task
 * 
 * @param {XMLDocument object} myDoc Xml document
 * @param {String} identifier Task identifier(id)
 * @param {String} taskTitle Task title
 * @param {Boolean} parsons2D Is task 2D parsons problem or not
 * @param {Number} canvasHeight Calculated height the task canvas has to be
 */
function add_metadata(myDoc, identifier, taskTitle, parsons2D, canvasHeight, title_no, title_ny, title_en) { //, prompt_no, prompt_ny, prompt_en){ //You can add prompt text, but why use this?
	//MAIN FILE
	let ai = myDoc.getElementsByTagName('assessmentItem');
	let assessmentItem = ai[0];
	//responseDeclarations = assessmentItem[0].getElementsByTagName('responseDeclaration')
	addAttribute(assessmentItem, "identifier", identifier)
	addAttribute(assessmentItem, "title", taskTitle)

	//Currently, we dont see the need for the prompt text, so we just leave it empty
	let newPromptTextNO = "";

	let itemBody = assessmentItem.getElementsByTagName('itemBody')[0];
	addAttribute(itemBody, "inspera:defaultLanguage", "no_no");
	addAttribute(itemBody, "inspera:supportedLanguages", "no_no,en_us,no_no_ny");

	try {
		//Set title text
		let title = itemBody.getElementsByTagName('p');
		title[0].innerHTML = title_no;

		/*
		let englishTitle = addChildWithValue(myDoc, itemBody, "div", "");
		addAttribute(englishTitle,"lang","en_us");
		addAttribute(englishTitle,"style","display: none;");
	
		let nynorskTitle = addChildWithValue(myDoc, itemBody, "div", "");
		addAttribute(nynorskTitle,"lang","no_no_ny");
		addAttribute(nynorskTitle,"style","display: none;");
		*/
		var tempEn = document.createElement("div");

		tempEn.innerHTML = title_en;
		addLanguageToAllTags(tempEn, "en_us")
		itemBody.innerHTML += tempEn.innerHTML;

		var tempNy = document.createElement("div");

		tempNy.innerHTML = title_ny;
		addLanguageToAllTags(tempNy, "no_no_ny")
		itemBody.innerHTML += tempNy.innerHTML;

		//We add this as a last element, so the graphicGapMatchInteraction can use insertBefore on lastChild(this one). 
		//graphicGapMatchInteraction has to be after all text
		itemBody.innerHTML += '<p style=""> </p>'

	} catch (err) {
		console.error(err);
		console.log(title_no);
		alert("Task text cant be made into XHTML, try with less styling. See console log for more information.")
	}


	let graphicGapMatchInteraction = assessmentItem.getElementsByTagName('graphicGapMatchInteraction')[0];

	//Set canvas height
	//Should do here, but the canvasHeight is in generate_python_lines instead, so im doing it there
	addAttribute(graphicGapMatchInteraction, "inspera:canvasHeight", canvasHeight.toString());

	//Set freeplacing
	if (!parsons2D) {
		addAttribute(graphicGapMatchInteraction, "class", "freeplacing markHotspots")
	}
	//Set prompt text
	let prompt = graphicGapMatchInteraction.getElementsByTagName("prompt")[0];
	addAttribute(prompt, "inspera:label-lang-no_no", newPromptTextNO);
	addAttribute(prompt, "inspera:label-lang-en_us", newPromptTextNO);
	addAttribute(prompt, "inspera:label-lang-no_no_ny", newPromptTextNO);
	prompt.firstChild.data = newPromptTextNO;

	let lastNode = itemBody.lastChild; //Last child is an empty <p/>
	itemBody.insertBefore(graphicGapMatchInteraction, lastNode); //Makes sure the graphicGapMatchInteraction comes as the bottom

	//itemBody.insertBefore(englishTitle, graphicGapMatchInteraction); //Place the p in front of norwegian/original p
	//itemBody.insertBefore(nynorskTitle, graphicGapMatchInteraction);
}

/**
 * Adds an empty drop area (one not connected to a drag area) to the given task
 * @param {XMLDocument object} myDoc Xml document
 * @param {Number} hotspotX Drop area starting x position
 * @param {Number} hotspotY Drop area starting y position
 * @param {Number} hotspotWidth Drop area width
 * @param {Number} hotspotHeight Drop area height
 */
function add_empty_hotspot(myDoc, hotspotX, hotspotY, hotspotWidth, hotspotHeight) {
	let newAssociableHotspotName = "associableHotspot" + generateID();
	let hotspotCoords = hotspotX.toString() + "," + hotspotY.toString() + "," + (hotspotX + hotspotWidth).toString() + "," + (hotspotY + hotspotHeight).toString();

	let assessmentItem = myDoc.getElementsByTagName('assessmentItem');
	let graphicGapMatchInteraction = assessmentItem[0].getElementsByTagName('graphicGapMatchInteraction')[0];


	//Create associableHotspot
	let associableHotspot = addChildWithAttribute(myDoc, graphicGapMatchInteraction, "associableHotspot", "coords", hotspotCoords);
	addAttribute(associableHotspot, "identifier", newAssociableHotspotName);
	addAttribute(associableHotspot, "hotspotLabel", "1");
	addAttribute(associableHotspot, "shape", "rect");
	addAttribute(associableHotspot, "matchMax", "0");

	return newAssociableHotspotName;
}

/**
 * Adds a drag and drop pair to the given task
 * Each drag area must support no, ny and en languages
 * @param {XMLDocument object} myDoc Xml document
 * @param {String} textInBox Text in drag area
 * @param {Number} boxX1 Drag area X position
 * @param {Number} boxY1 Drag area Y position
 * @param {Number} boxWidth1 Drag area width (not currently used, calculates the width automatically)
 * @param {Number} boxHeight1 Drag area height 
 * @param {Number} hotspotX Drop area X position
 * @param {Number} hotspotY Drop area Y position
 * @param {Number} hotspotWidth Drop area width
 * @param {Number} hotspotHeight Drop area height
 */
function add_draggable_pair(myDoc, textInBox, boxX1, boxY1, boxWidth1, boxHeight1, hotspotX, hotspotY, hotspotWidth, hotspotHeight) {
	let boxX = boxX1.toString();
	let boxY = boxY1.toString();
	let boxWidth = get_length_of_word(textInBox).toString(); //str(len(textInBox)*10) #str(boxWidth)
	let boxHeight = boxHeight1.toString();
	let newGapImgName = "gapImg" + generateID();
	let newAssociableHotspotName = "associableHotspot" + generateID();
	let newGA = newGapImgName + " " + newAssociableHotspotName;
	let hotspotCoords = hotspotX.toString() + "," + hotspotY.toString() + "," + (hotspotX + hotspotWidth).toString() + "," + (hotspotY + hotspotHeight).toString();

	let assessmentItem = myDoc.getElementsByTagName('assessmentItem');
	let responseDeclarations = assessmentItem[0].getElementsByTagName('responseDeclaration');

	//Add value to correctResponses
	let correctResponses = responseDeclarations[0].getElementsByTagName('correctResponse');
	addChildWithValue(myDoc, correctResponses[0], "value", newGA);

	//Add mapEntry to mapping
	let mapping = responseDeclarations[0].getElementsByTagName('mapping');
	let ele = addChildWithAttribute(myDoc, mapping[0], "mapEntry", "mapKey", newGA);
	addAttribute(ele, "mappedValue", "1");

	//Add responseDecleration
	let rd = addChildWithAttribute(myDoc, assessmentItem[0], "responseDeclaration", "baseType", "point");
	addAttribute(rd, "cardinality", "single");
	addAttribute(rd, "identifier", newGapImgName);

	let graphicGapMatchInteraction = assessmentItem[0].getElementsByTagName('graphicGapMatchInteraction')[0];

	let gi = addChildWithAttribute(myDoc, graphicGapMatchInteraction, "gapImg", "identifier", newGapImgName);
	addAttribute(gi, "matchMax", "");

	let obj = addChildWithAttribute(myDoc, gi, "object", "x", boxX);
	addAttribute(obj, "y", boxY);
	addAttribute(obj, "width", boxWidth);
	addAttribute(obj, "height", boxHeight);

	let div = addChildWithAttribute(myDoc, obj, "div", "class", "text");
	addChildWithValue(myDoc, div, "p", textInBox);
	addAttribute(div, "inspera:label-lang-en_us", textInBox);
	addAttribute(div, "inspera:label-lang-no_no_ny", textInBox);

	//Create associableHotspot
	let associableHotspot = addChildWithAttribute(myDoc, graphicGapMatchInteraction, "associableHotspot", "coords", hotspotCoords);
	addAttribute(associableHotspot, "identifier", newAssociableHotspotName);
	addAttribute(associableHotspot, "hotspotLabel", "1");
	addAttribute(associableHotspot, "shape", "rect");
	addAttribute(associableHotspot, "matchMax", "0");

	//ResponseProcessing and isNull
	let responseProcessing = assessmentItem[0].getElementsByTagName('responseProcessing')[0];
	let responseConditions = responseProcessing.getElementsByTagName('responseCondition');
	//ResponseCondition 1
	let andResponse = responseConditions[0].getElementsByTagName('and')[0];
	let isNull = addChildWithValue(myDoc, andResponse, "isNull", "");
	addChildWithAttribute(myDoc, isNull, "variable", "identifier", newGapImgName);
	//ResponseCondition 2
	andResponse = responseConditions[1].getElementsByTagName('and')[0];
	isNull = addChildWithValue(myDoc, andResponse, "isNull", "");
	addChildWithAttribute(myDoc, isNull, "variable", "identifier", newGapImgName);

	let responseElseIfs = responseConditions[1].getElementsByTagName('responseElseIf');
	//ResponseElseIf 1
	andResponse = responseElseIfs[0].getElementsByTagName('and')[0];
	let member = addChildWithValue(myDoc, andResponse, "member", "");
	let baseValue = addChildWithValue(myDoc, member, "baseValue", newGA);
	addAttribute(baseValue, "baseType", "directedPair");
	addChildWithAttribute(myDoc, member, "variable", "identifier", "RESPONSE");

	//ResponseElseIf 1
	let orResponse = responseElseIfs[1].getElementsByTagName('or')[0];
	member = addChildWithValue(myDoc, orResponse, "member", "");
	baseValue = addChildWithValue(myDoc, member, "baseValue", newGA);
	addAttribute(baseValue, "baseType", "directedPair");
	addChildWithAttribute(myDoc, member, "variable", "identifier", "RESPONSE");

	return [newGapImgName, newAssociableHotspotName]
}

function connectDragAreaToDropArea(myDoc, newGapImgName, newAssociableHotspotName) {
	let newGA = newGapImgName + " " + newAssociableHotspotName;
	let assessmentItem = myDoc.getElementsByTagName('assessmentItem');
	let responseDeclarations = assessmentItem[0].getElementsByTagName('responseDeclaration');

	//Add value to correctResponses
	let correctResponses = responseDeclarations[0].getElementsByTagName('correctResponse');
	addChildWithValue(myDoc, correctResponses[0], "value", newGA);

	//Add mapEntry to mapping
	let mapping = responseDeclarations[0].getElementsByTagName('mapping');
	let ele = addChildWithAttribute(myDoc, mapping[0], "mapEntry", "mapKey", newGA);
	addAttribute(ele, "mappedValue", "1");
	//ResponseProcessing and isNull
	let responseProcessing = assessmentItem[0].getElementsByTagName('responseProcessing')[0];
	let responseConditions = responseProcessing.getElementsByTagName('responseCondition');

	let responseElseIfs = responseConditions[1].getElementsByTagName('responseElseIf');
	//ResponseElseIf 1
	andResponse = responseElseIfs[0].getElementsByTagName('and')[0];
	let member = addChildWithValue(myDoc, andResponse, "member", "");
	let baseValue = addChildWithValue(myDoc, member, "baseValue", newGA);
	addAttribute(baseValue, "baseType", "directedPair");
	addChildWithAttribute(myDoc, member, "variable", "identifier", "RESPONSE");

	//ResponseElseIf 1
	let orResponse = responseElseIfs[1].getElementsByTagName('or')[0];
	member = addChildWithValue(myDoc, orResponse, "member", "");
	baseValue = addChildWithValue(myDoc, member, "baseValue", newGA);
	addAttribute(baseValue, "baseType", "directedPair");
	addChildWithAttribute(myDoc, member, "variable", "identifier", "RESPONSE");

}

function add_distractor(myDoc, textInBox, boxX1, boxY1, boxWidth1, boxHeight1) {
	let boxX = boxX1.toString();
	let boxY = boxY1.toString();
	let boxWidth = get_length_of_word(textInBox).toString(); //str(len(textInBox)*10) #str(boxWidth)
	let boxHeight = boxHeight1.toString();
	let newGapImgName = "gapImg" + generateID();

	let assessmentItem = myDoc.getElementsByTagName('assessmentItem');
	let responseDeclarations = assessmentItem[0].getElementsByTagName('responseDeclaration');

	//Add responseDecleration
	let rd = addChildWithAttribute(myDoc, assessmentItem[0], "responseDeclaration", "baseType", "point");
	addAttribute(rd, "cardinality", "single");
	addAttribute(rd, "identifier", newGapImgName);

	let graphicGapMatchInteraction = assessmentItem[0].getElementsByTagName('graphicGapMatchInteraction')[0];

	//Set freeplacing
	/*
	if(!parsons2D){
		addAttribute(graphicGapMatchInteraction, "class", "freeplacing markHotspots")
	}
	*/
	let gi = addChildWithAttribute(myDoc, graphicGapMatchInteraction, "gapImg", "identifier", newGapImgName);
	addAttribute(gi, "matchMax", "");

	let obj = addChildWithAttribute(myDoc, gi, "object", "x", boxX);
	addAttribute(obj, "y", boxY);
	addAttribute(obj, "width", boxWidth);
	addAttribute(obj, "height", boxHeight);

	let div = addChildWithAttribute(myDoc, obj, "div", "class", "text");
	addChildWithValue(myDoc, div, "p", textInBox);
	addAttribute(div, "inspera:label-lang-en_us", textInBox);
	addAttribute(div, "inspera:label-lang-no_no_ny", textInBox);

	//ResponseProcessing and isNull
	let responseProcessing = assessmentItem[0].getElementsByTagName('responseProcessing')[0];
	let responseConditions = responseProcessing.getElementsByTagName('responseCondition');
	//ResponseCondition 1
	let andResponse = responseConditions[0].getElementsByTagName('and')[0];
	let isNull = addChildWithValue(myDoc, andResponse, "isNull", "");
	addChildWithAttribute(myDoc, isNull, "variable", "identifier", newGapImgName);
	//ResponseCondition 2
	andResponse = responseConditions[1].getElementsByTagName('and')[0];
	isNull = addChildWithValue(myDoc, andResponse, "isNull", "");
	addChildWithAttribute(myDoc, isNull, "variable", "identifier", newGapImgName);

	let responseElseIfs = responseConditions[1].getElementsByTagName('responseElseIf');
	//ResponseElseIf 1
	andResponse = responseElseIfs[0].getElementsByTagName('and')[0];
}

/**
 * Generates a unique id for a task
 * @return {String} A unique id
 */
function generateID() {
	function s4() {
		return Math.floor((1 + Math.random()) * 0x10000)
			.toString(16)
			.substring(1);
	}
	return '_' + s4() + s4() + '-' + s4() + '-' + s4() + '-' + s4() + '-' + s4() + s4() + s4();
}

/**
 * Returns the exact width of a text given font
 * @param {String} text The text you want to get the width of
 * @param {String} font The font specs. Ex: '14px Arial, sans-serif'
 * @return {Number} Returns the width of the text given a specific font
 */
function getTextWidth(text, font) {
	// re-use canvas object for better performance
	var canvas = getTextWidth.canvas || (getTextWidth.canvas = document.createElement("canvas"));
	var context = canvas.getContext("2d");
	context.font = font;
	var metrics = context.measureText(text);
	return metrics.width;
}

/**
 * Returns the exact with of a given word based on the font size Inspera uses
 * @param {String} word The text you want to get the length of
 * @return {Number} Returns the width of the text given the Inspera font
 */
function get_length_of_word(word) {
	//Exact width based on the Inspera font used
	let width = getTextWidth(word, "14px Arial, sans-serif")
	//Extra width has to be added due to some margins and paddings Inspera adds
	let extraWidth = 14;
	width += extraWidth;
	return width;
}

/**
 * Based on the given code lines, figure out the deepest indentation / max number of tabs and indentations used.
 * In a 2D grid this decides how many columns are needed.
 * @param {String or [Strings]} lines The code lines written by the user
 * @param {Number} tabSize The used tab size (2 spaces, 4 spaces, 1 tab etc.)
 * @return {Number} Returns the max number of indentations used in the code
 */
function getMaxTabs(lines, tabSize) {
	let maxTabs = 0;
	for (let i = 0; i < lines.length; i++) {
		let line = lines[i];
		let num = countTabs(line, tabSize);
		if (num > maxTabs) {
			maxTabs = num
		}
	}
	return maxTabs
}

/**
 * Based on the given code lines, figure out the indentation size used (2 spaces, 4 spaces, 1 tab etc.) 
 * The first tab found will be returned set as the standard tab used.
 * @param {String or [Strings]} lines The code lines written by the user
 * @return {Number} Returns the first tab size it finds in the code
 */
function findTabSize(lines) {
	for (let i = 0; i < lines.length; i++) {
		let line = lines[i];
		let trimmed = line.trimLeft(" ");
		let ts = line.length - trimmed.length;
		if (ts > 1) {
			return ts;
		}
	}
	return 4;
}

/**
 * Given a specific code line, it figures out how many indentations it has.
 * This decides what column the code line has to be placed in.
 * def hello(): #Has 0
 *     print("ok") #Has 1
 * @param {String} line The code line
 * @param {Number} tabSize The standard tab size used in the code
 * @return {Number} Returns the number of tabs the code line has.
 */
function countTabs(line, tabSize) {
	let numTabs = (line.split("\t").length - 1); //Count occurances of \t
	let trimmed = line.trimLeft(" ");
	let numSpaces = (line.length - trimmed.length) / tabSize;
	if (numSpaces > numTabs) {
		return numSpaces;
	} else {
		return numTabs;
	}
}

/**
 * Removed \t, \n and spaces from the ends of a code line 
 * @param {String} line The code line
 * @return {String} A code line stripped from tabs, newlines and spaces at the edges
 */
function stripMe(line) {
	return line.trim(); //Should remove \t \n and " "
}

/**
 * Decides the positions where each drag area should initially be placed in the task.
 * Goes through each line of code and places these drag areas randomly under the drop areas in Inspera.
 * Creates a following object:
 * startOptions = {
 * 	{String} codeLine : [xPos, yPos],
 * }
 * @param {String or [Strings]} lines The code lines
 * @param {Number} height The height each drag area is given
 * @param {String or [Strings]} distractors The distractor code lines 
 * @return {Object} Returns an object where each code line is the key to an x,y position
 */
function generateStartOptions(lines, height, distractors) {
	/*
	var startOptions = {
		'String': [x,y],
		'print("hei")': [20,10],
		'def myok():': [30,10]
	};
	*/

	let maxWidth = 600;
	let spaceBetween = 20;
	let startY = (height * 3) + (lines.length * height);

	let startOptions = {};

	let all = lines.concat(distractors);
	all = all.sort(() => 0.5 - Math.random());

	let row = 1;
	let startXPos = 20;
	let currentPointInRow = startXPos;
	while (all.length != 0) {
		let randomIndex = getRandomInt(all.length - 1);
		let line = all.splice(randomIndex, 1);
		let length = get_length_of_word(line);
		if (currentPointInRow + length < (maxWidth - spaceBetween)) {
			startOptions[line] = [currentPointInRow, startY + ((height + spaceBetween) * row)]
		} else {
			row += 1;
			currentPointInRow = startXPos;
			startOptions[line] = [currentPointInRow, startY + ((height + spaceBetween) * row)]
		}
		currentPointInRow += length + spaceBetween;
	}

	return startOptions;
}

/**
 * Returns a random integer 
 * @param {Number} max The random integer will be between 0 and max
 * @return {Number} Returns a random integer
 */
function getRandomInt(max) {
	let rand = Math.floor(Math.random() * Math.floor(max));
	return rand;
}

//Make canvas height the highest drag area position + 100
/**
 * Goes through the startOptions object and finds the highest x position.
 * This plus some extra margin decides the total size the task canvas should be
 * @param {Object} startOptions Object where each code line is the key to an x,y position
 * @return {Number} Returns the height the task canvas has to be in Inspera
 */
function getCanvasHeight(startOptions) {
	let highestYPos = 0;
	for (key in startOptions) {
		let y = startOptions[key][1];
		if (y > highestYPos) {
			highestYPos = y;
		}

	}
	return highestYPos + 100;
}

/**
 * This function calculates 
 */
function addAllPermutations(myDoc, gapImages, associableHotspots, dag) {
	let calculatePermutations = new CalculatePermutations(dag);
	console.log(calculatePermutations.getErrorRates());
	let topologicalSorts = calculatePermutations.getAllTopologicalSorts();

	for (let i = 0; i < topologicalSorts.length; i++) {
		let topologicalSort = topologicalSorts[i];
		for (let j = 0; j < topologicalSort.length; j++) {
			connectDragAreaToDropArea(myDoc, gapImages[topologicalSort[j]], associableHotspots[j])
		}
	}

}

/**
 * This is the main function that goes through all code lines and distractor and creates the appropriate drag area, drop area or drag-and-drop pair.
 * This function mainly adds and creates everything that is needed for a single task.
 * @param {XMLDocument object} myDoc The xml document (A single task)
 * @param {String or [Strings]} lines The code lines
 * @param {Boolean} parsons2D The given task should be a 2D parsons problem or not
 * @param {String or [Strings]} distractors The distractor code lines
 * @returns {Number} Returns the canvas height that is needed for this specific task
 */
function generate_python_lines(myDoc, lines, parsons2D, distractors, dag) {
	let startY = 50;
	let maxWidth = 600;
	let dragHeight = 20;
	let dropHeight = 24;

	let startOptions = generateStartOptions(lines, (dropHeight > dragHeight ? dropHeight : dragHeight), distractors);
	let canvasHeight = getCanvasHeight(startOptions);

	if (parsons2D) {
		let width = 50;
		let tabSize = findTabSize(lines);
		let maxTabs = getMaxTabs(lines, tabSize);
		/*
		2D array of associableHotspots representing the drop area grid
		[
			[1,2,3],
			[1,2,3],
			[1,2,3]
		]
		*/
		let associableHotspots = []
		//Array of gapImages where position is the same as in lines.
		let gapImages = [];

		for (let i = 0; i < lines.length; i++) {
			associableHotspots.push([])
			let line = lines[i];

			let tabs = countTabs(line, tabSize);
			let theString = stripMe(line);
			let startOptionPair = startOptions[line];
			let gridStartX = (maxWidth - ((maxTabs + 0.5) * (width + 1))) / 2;
			for (let i = 0; i < maxTabs + 1; i++) {
				let startX = gridStartX + (width * i) + i;
				if (i == tabs) {
					//Returns [newGapImgName, newAssociableHotspotName]
					let gapAndHotspot = add_draggable_pair(myDoc, theString, startOptionPair[0], startOptionPair[1], width, dragHeight, startX, startY, width, dropHeight);
					associableHotspots[associableHotspots.length - 1].push(gapAndHotspot[1]);
					gapImages.push(gapAndHotspot[0]);
				} else {
					let hotspot = add_empty_hotspot(myDoc, startX, startY, width, dropHeight);
					associableHotspots[associableHotspots.length - 1].push(hotspot)
				}
			}
			startY += dropHeight + 1;
		}
		console.log(associableHotspots)
		for (let i = 0; i < distractors.length; i++) {
			let startOptionPair = startOptions[distractors[i]];
			add_distractor(myDoc, distractors[i], startOptionPair[0], startOptionPair[1], 10, dragHeight);
		}


	} else {
		let width = 500;
		/*
		Array of associableHotspots representing the drop area rows
		[
			1,
			2,
			3
		]
		*/
		let associableHotspots = []
		//Array of gapImages where position is the same as in lines.
		let gapImages = [];
		for (let i = 0; i < lines.length; i++) {
			let line = lines[i];
			let theString = stripMe(line);
			let startOptionPair = startOptions[line];
			let startX = 50;
			let gapAndHotspot = add_draggable_pair(myDoc, theString, startOptionPair[0], startOptionPair[1], width, dragHeight, startX, startY, width, dropHeight);

			associableHotspots.push(gapAndHotspot[1]);
			gapImages.push(gapAndHotspot[0]);

			startY += dropHeight + 1;
		}
		for (let i = 0; i < distractors.length; i++) {
			//let startOptionPair = startOptions.pop(getRandomInt(startOptions.length-1));
			let startOptionPair = startOptions[distractors[i]];
			add_distractor(myDoc, distractors[i], startOptionPair[0], startOptionPair[1], 10, dragHeight);
		}
		addAllPermutations(myDoc, gapImages, associableHotspots, dag);
	}
	return canvasHeight;
}


/**
 * A helper function that adds a xml child element with a value to the parent element
 * <childName>value</childName>
 * @param {XMLDocument object} myDoc The xml document
 * @param {XMLElement} parent The parent element
 * @param {String} childName The name of the new child element
 * @param {String} value The value the new child element should have
 * @return {XMLElement} Returns the newly created child element
 */
function addChildWithValue(myDoc, parent, childName, value) {
	let newEle = myDoc.createElement(childName);
	let newText = myDoc.createTextNode(value);
	newEle.appendChild(newText);
	parent.appendChild(newEle);
	return newEle
}

/**
 * A helper function that adds a xml child element with an attribute and an attribute value to the parent element
 * <elementName attributeName="value"/>
 * @param {XMLDocument object} myDoc The xml document
 * @param {XMLElement} parent The parent element
 * @param {String} elementName The name of the new child element
 * @param {String} attributeName The name of the attribute
 * @param {String} value The attribute value 
 * @return {XMLElement} Returns the newly created child element
 */
function addChildWithAttribute(myDoc, parent, elementName, attributeName, value) {
	let newEle = myDoc.createElement(elementName);
	newEle.setAttribute(attributeName, value);
	parent.appendChild(newEle);
	return newEle
}
/**
 * A helper function that adds an attribute and attribute value to a given element
 * <element attributeName="value" />
 * @param {XMLElement} element The given xml element
 * @param {String} attributeName The new attribute name
 * @param {String} value The new attribute value
 * @return {XMLElement} The xml element 
 */
function addAttribute(element, attributeName, value) {
	element.setAttribute(attributeName, value);
	return element
}


function getRandomSubsetOfDistractors(arr, n) {
	var result = new Array(n),
		len = arr.length,
		taken = new Array(len);
	if (n > len)
		return arr;
	while (n--) {
		var x = Math.floor(Math.random() * len);
		result[n] = arr[x in taken ? taken[x] : x];
		taken[x] = --len in taken ? taken[len] : len;
	}
	return result;
}







/**
 * This is the main function and the function first called when exporting a task.
 * NB! Everything starts here!
 * The first step is to delete any old versions of the zipThis folder before continuing to create the new tasks.
 * @param {Object} jsonObject The JSON object created in the GUI
 * @param {String} filepath The filepath chosen by the user where the zipped file should be placed
 */
function run_dnd(jsonObject, filepath) {
	let rimraf = require('rimraf');

	/*
	dag = [
		[1,0,0,0,0,0],
		[0,1,0,0,0,0],
		[0,0,1,1,0,0],
		[0,1,0,1,0,0],
		[1,1,0,0,1,0],
		[1,0,1,0,0,1],
	  ];
	let calculatePermutations = new CalculatePermutations(currentEdges);
	console.log(calculatePermutations.getErrorRates());

	*/
	//Deletes old zipThis file
	rimraf(__dirname + '/zipThis', function () { continue_dnd(jsonObject, filepath); });
}

/**
 * A continuation of the run_dnd function. This gets called after the old zipThis folder has been deleted.
 * This function now creates a new zipThis folder and places all tasks and the manifest inside the folder before zipping it.
 * The function goes through all tasks and creates the xml files for each of them.
 * @param {Object} dataAll The JSON object created in the GUI
 * @param {String} filepath The filepath chosen by the user where the zipped file should be placed
 */
function continue_dnd(dataAll, filepath) {
	//const logger = require('electron').remote.require('./logger');
	//npm install mkdirp

	console.log("Data objects to create")
	console.log(dataAll);
	let mkdirp = require('mkdirp');
	mkdirp(__dirname + '/zipThis', function (err) {
		if (err) {
			alert("Create file errors:" + err);
		}
	});
	let myManifest = read_manifest();

	if (!Array.isArray(dataAll)) {
		dataAll = [dataAll]
	}

	let distractors = [];
	let taskIdentifiers = [];
	let taskNames = [];

	for (let i = 0; i < dataAll.length; i++) {
		data = dataAll[i];
		let numberOfTasksToGenerate = 1;//data.generateNumber;
		let distractorSubsetSize = 2;


		let title_no = '<div>' + data.description.no + '</div>';//"<p><strong>Norsk</strong></p>"
		let title_ny = '<div>' + data.description.nyno + '</div>';//"<p><strong>Nynorsk</strong></p>"
		let title_en = '<div>' + data.description.eng + '</div>';//"<p><strong>English</strong></p>"

		for (let i = 0; i < numberOfTasksToGenerate; i++) {
			distractors = getRandomSubsetOfDistractors(data.distractors, distractorSubsetSize)
			parsons2D = data.parsons2d;
			lines = data.code;
			lines = lines.split("\n");

			let taskIdentifier = generateID();
			taskIdentifiers.push(taskIdentifier);

			taskNames.push(data.fileName)

			let myDoc = read_xml();
			dag = [
				[1, 0, 0, 0, 0, 0],
				[0, 1, 0, 0, 0, 0],
				[0, 0, 1, 1, 0, 0],
				[0, 1, 0, 1, 0, 0],
				[1, 1, 0, 0, 1, 0],
				[1, 0, 1, 0, 0, 1],
			];
			let canvasHeight = generate_python_lines(myDoc, lines, parsons2D, distractors, dag);
			add_metadata(myDoc, taskIdentifier, data.fileName, parsons2D, canvasHeight, title_no, title_ny, title_en);

			write_xml(myDoc, taskIdentifier);
		}
	}
	add_manifest_data(myManifest, taskIdentifiers, taskNames);

	write_manifest(myManifest);


	setTimeout(function () { zipAndDelete(filepath) }, 500);

}

/**
 * This function zippes the zipThis folder and places it in the correct filepath.
 * After this step the zip file is ready to be uploaded to Inspera
 * @param {String} filepath The filepath chosen by the user
 */
function zipAndDelete(filepath) {
	let zipFolder = require('zip-folder');

	//filepath is path the user chose
	zipFolder(__dirname + '/zipThis', filepath + '.zip', function (err) {
		if (err) {
			console.log('Error zip folder: ', err);
		}
	});
	alert("Download successful! \n\nYou can now upload the zip file to Inspera.");

	let rimraf = require('rimraf');
	//Uncomment this if you want zipThis to be deleted. NB! This throws an error now! Dont know why
	//rimraf(__dirname+'/zipThis', function () { console.log('zipThis deleted'); });

}

/**
 * Modules exported for unit testing
 * 
 * NB! Only functions NOT using browser/html specific functions can be
 * unit tested! DOMParser, XMLSerializer, document etc. does not work in 
 * unit tests running from command line!
 */
module.exports._test = {
	generateID: generateID,
	getRandomInt: getRandomInt,
	findTabSize: findTabSize,
	getMaxTabs: getMaxTabs,
	countTabs: countTabs,
	stripMe: stripMe,
	getCanvasHeight: getCanvasHeight,
}
